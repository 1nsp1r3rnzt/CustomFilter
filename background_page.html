<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<script language="JavaScript" src="src/db/DbObj.js"></script>
		<script language="JavaScript" src="src/db/Rule.js"></script>
		<script language="JavaScript" src="src/db/Word.js"></script>
		<script language="JavaScript" src="../src/util.js"></script>
		<script language="JavaScript">
			function getBadgeAction (tabId) 
			{
				return function (count) 
				{
					try 
					{
						chrome.browserAction.setBadgeText({
							text:''+count,
							tabId: tabId
						});
						chrome.browserAction.setTitle({
							title:count+"件ブロックしました",
							tabId:tabId
						});
					} catch (ex) {
						alert(ex)
					}
					chrome.tabs.sendRequest(tabId, {
						command: 'badge'
					}, getBadgeAction(tabId));
				}
			};
			var initDone = false;
			var peer = RulePeer.getInstance();
			var wordPeer = WordPeer.getInstance();
			var existingTabs = new Array();
			
			function onStart () 
			{
				peer.createTable(createWordTable);
			}
			function createWordTable () 
			{
				wordPeer.createTable(loadLists);
			}
			function loadLists () 
			{
				peer.select('', 
					onRuleListLoaded, null);
			}
			function onRuleListLoaded (list) 
			{
				ruleList = list;
				wordPeer.select('', onWordListLoaded, null);
			}
			function removeFromExistingTabList (tabIdToRemove)
			{
				for (var id in existingTabs)
				{
					if (tabIdToRemove==id) existingTabs[id] = null;
				}
			}
			function addToExistingTabList (tabIdToAdd)
			{
				existingTabs[tabIdToAdd] = true;				
			}
			function onWordListLoaded (wordList) 
			{
				var ruleMap = new Array();
				for (var i=0, l=ruleList.length; i<l; i++) 
				{
					ruleMap[ruleList[i].rule_id] = ruleList[i];
				}
				for (var i = 0, l = wordList.length; i < l; i++) 
				{
					var rule = ruleMap[wordList[i].rule_id];
					if (rule) 
					{
						rule.words.push(wordList[i]);
					}
				}
				loadRulePickerSrc();
			}
			
			function reloadLists () 
			{
				loadLists();
			}
			
			function openRulePicker (selectedRule) 
			{
				try 
				{
					chrome.tabs.getSelected(null,function(tab)
					{
						chrome.tabs.sendRequest(tab.id, 
						{
							command: 'ruleMaker',
							src: rulePickerSrc,
							rule: selectedRule,
							appliedRuleList: appliedRuleMap[tab.id]
						}, getRulePickerOnCommandFunc(tab.id));
					});
				} 
				catch (ex) {alert(ex)}
			}
			function getRulePickerOnCommandFunc (tabId)
			{
				return function (command)
				{
					try 
					{
						var exPeer;
						if ('save' == command.command) 
						{
							var rule =command.obj;
							var saveRuleTask = new SaveRuleTask(rule, reloadLists, tabId);
							saveRuleTask.exec();
						}
							
						if ('delete' == command.command) 
						{
							exPeer.deleteObject(command.obj, reloadLists);
						}
					} 
					catch (e) 
					{
						alert(e)
					}
					chrome.tabs.getSelected(null,function(tab)
					{
						chrome.tabs.sendRequest(tab.id, 
						{
							command: 'ruleMakerRegister'
						}, rulePickerOnCommand);
					});
					
				}
			}
			var tabOnUpdate = function(tabId, changeInfo, tab)
			{
				addToExistingTabList(tabId);
				// ON/OFF
				var isDisabled = ('true' == localStorage.blockDisabled);
				if (isDisabled) {
					return;
				}
				var url = tab.url;
				if (url !== undefined && changeInfo.status == "complete") 
				{
					chrome.tabs.sendRequest(tabId,
					{
						command:'init',
						rules: ruleList,
						tabId: tabId
					},
					function(list)
					{
						try {
							chrome.browserAction.setIcon(
							{
								path:((list.length>0)?'icon.png':'icon_disabled.png'),
								tabId:tabId
							});
						} catch (ex) 
						{
							alert(ex)
						}
						appliedRuleMap[tab.id] = list;
						chrome.tabs.sendRequest(tab.id, 
						{
							command: 'badge'
						}, getBadgeAction(tabId));
					});
				}
			}
			
			function getAppliedRules (cb) 
			{
				chrome.tabs.getSelected(null,function(tab)
				{
					try 
					{
						cb(appliedRuleMap[tab.id]);
					} 
					catch (ex) {alert(ex)}
				});
				
			}
			var rulePickerSrc = '';
			function loadRulePickerSrc()
			{
				var xhr = new XMLHttpRequest();
				xhr.onreadystatechange = function()
				{
					if (xhr.readyState==4) 
					{
						if (xhr.status==0 || xhr.status==200) 
						{
							rulePickerBody = xhr.responseXML.getElementById('rule_maker_body');
							var div = document.createElement('DIV');
							div.appendChild(rulePickerBody);
							rulePickerSrc = div.innerHTML;
						}
					}
					
				}
				xhr.open("GET", chrome.extension.getURL('/rule_maker.html'), true);
				xhr.send();
			}
			
			var SaveRuleTask = function (rule, reloadLists, tabId) 
			{
				var saveWords = new Array();
				var deleteWords = new Array();
				
				for (var i=0, l=rule.words.length; i<l; i++) 
				{
					var word = rule.words[i];
					if (word.isNew) 
					{
						saveWords.push(word);
					}
					else if (word.deleted) 
					{
						deleteWords.push(word);
					}
				}
				
				this.rule = rule;
				this.tabId = tabId;
				
				this.saveWords = saveWords;
				this.deleteWords = deleteWords;
				
				this.reloadLists /* function */ = reloadLists;
				//すべてがおわったらreloadListsを実行する				
			};
			SaveRuleTask.prototype.exec = function () 
			{
				//peer, wordPeer
				peer.saveObject(this.rule, this.getNextTask());	
			};
			SaveRuleTask.prototype.getNextTask = function () 
			{
				var self = this;
				return function () 
				{
					var nextSaveWord = self.getNextSaveWord();
					if (nextSaveWord) 
					{
						wordPeer.saveObject(nextSaveWord, self.getNextTask());
						return;
					}
					var nextDeleteWord = self.getNextDeleteWord();
					if (nextDeleteWord) 
					{
						wordPeer.deleteObject(nextDeleteWord, self.getNextTask());
						return;
					}
					chrome.tabs.sendRequest(self.tabId,
					{
						command:'ruleSaveDone',
						rules: ruleList,
						tabId: self.tabId,
						rule: self.rule
					}
					, getRulePickerOnCommandFunc(self.tabId)
					);
					self.reloadLists();
				}
			};
			SaveRuleTask.prototype.getNextSaveWord = function () 
			{
				for (var i=0, l=this.saveWords.length; i<l; i++) 
				{
					var word = this.saveWords[i];
					if (word.dirty) 
					{
						word.rule_id = this.rule.rule_id;
						return word;
					}
				}
				return null;
			};
			SaveRuleTask.prototype.getNextDeleteWord = function () 
			{
				for (var i=0, l=this.deleteWords.length; i<l; i++) 
				{
					var word = this.deleteWords[i];
					if (word.dirty) 
					{
						word.rule_id = this.rule.rule_id;
						return word;
					}
				}
			};

			var ruleList = new Array();
			var appliedRuleMap = new Array();
			if (!chrome.tabs.customBlockerOnUpdateSet)
			{
				chrome.tabs.onUpdated.addListener(tabOnUpdate);
				chrome.tabs.onRemoved.addListener
					(function(tabId, removeInfo) 
						{
							removeFromExistingTabList(tabId);
							appliedRuleMap[tabId] = null;
						});
				chrome.tabs.onSelectionChanged.addListener
					(function(_tabId, selectInfo) 
						{
							var tabId = parseInt(_tabId);
							var ids = new Array();
							for (var _index in existingTabs) 
							{ 
								var index = parseInt(_index);
								if (existingTabs[index] && index!=tabId)
								{
									//TODO send "stop" message to "index" tab.
									//try
									//{
										chrome.tabs.sendRequest(index, 
											{
												command: 'stop'
											}, getBadgeAction(index));
									//}
									//catch (ex) {console.log(ex);console.log("errorIndex=" + index);}
								}
									ids.push(index);
							}
							try
							{
								chrome.tabs.sendRequest(tabId, 
									{
										command: 'resume'
									}, getBadgeAction(tabId));
							}
							catch (ex) {console.log(ex);}
						});
			}
			chrome.tabs.customBlockerOnUpdateSet = true;			
		</script>
		<title>CustomBlocker</title>
	</head>
	<body onLoad="onStart()">
	</body>
</html>
